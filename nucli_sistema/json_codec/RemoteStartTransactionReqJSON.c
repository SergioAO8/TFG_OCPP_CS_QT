/**
 * stdout
 * This file has been autogenerated using quicktype https://github.com/quicktype/quicktype - DO NOT EDIT
 * This file depends of https://github.com/DaveGamble/cJSON, https://github.com/joelguittet/c-list and https://github.com/joelguittet/c-hashtable
 * To parse json data from json string use the following: struct <type> * data = cJSON_Parse<type>(<string>);
 * To get json data from cJSON object use the following: struct <type> * data = cJSON_Get<type>Value(<cjson>);
 * To get cJSON object from json data use the following: cJSON * cjson = cJSON_Create<type>(<data>);
 * To print json string from json data use the following: char * string = cJSON_Print<type>(<data>);
 * To delete json data use the following: cJSON_Delete<type>(<data>);
 */

#ifndef __STDOUT__
#define __STDOUT__

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <cJSON.h>
#include <hashtable.h>
#include <list.h>
#include "RemoteStartTransactionReqJSON.h"
#include "mystrdup.h"

#ifndef cJSON_Bool
#define cJSON_Bool (cJSON_True | cJSON_False)
#endif
#ifndef cJSON_Map
#define cJSON_Map (1 << 16)
#endif
#ifndef cJSON_Enum
#define cJSON_Enum (1 << 17)
#endif

static enum ChargingProfileKind cJSON_GetChargingProfileKindValue(const cJSON * j);
static cJSON * cJSON_CreateChargingProfileKind(const enum ChargingProfileKind x);

static enum ChargingProfilePurpose cJSON_GetChargingProfilePurposeValue(const cJSON * j);
static cJSON * cJSON_CreateChargingProfilePurpose(const enum ChargingProfilePurpose x);

static enum ChargingRateUnit cJSON_GetChargingRateUnitValue(const cJSON * j);
static cJSON * cJSON_CreateChargingRateUnit(const enum ChargingRateUnit x);

static enum RecurrencyKind cJSON_GetRecurrencyKindValue(const cJSON * j);
static cJSON * cJSON_CreateRecurrencyKind(const enum RecurrencyKind x);

static struct ChargingSchedulePeriod * cJSON_GetChargingSchedulePeriodValue(const cJSON * j);
static cJSON * cJSON_CreateChargingSchedulePeriod(const struct ChargingSchedulePeriod * x);
static void cJSON_DeleteChargingSchedulePeriod(struct ChargingSchedulePeriod * x);

static struct ChargingSchedule * cJSON_GetChargingScheduleValue(const cJSON * j);
static cJSON * cJSON_CreateChargingSchedule(const struct ChargingSchedule * x);
static void cJSON_DeleteChargingSchedule(struct ChargingSchedule * x);

static struct ChargingProfile * cJSON_GetChargingProfileValue(const cJSON * j);
static cJSON * cJSON_CreateChargingProfile(const struct ChargingProfile * x);
static void cJSON_DeleteChargingProfile(struct ChargingProfile * x);

static struct RemoteStartTransactionReq * cJSON_GetRemoteStartTransactionReqValue(const cJSON * j);
static cJSON * cJSON_CreateRemoteStartTransactionReq(const struct RemoteStartTransactionReq * x);
static void cJSON_DeleteRemoteStartTransactionReq(struct RemoteStartTransactionReq * x);

static enum ChargingProfileKind cJSON_GetChargingProfileKindValue(const cJSON * j) {
    enum ChargingProfileKind x = 0;
    if (NULL != j) {
        if (!strcmp(cJSON_GetStringValue(j), "Absolute")) x = CHARGINGPROFILEKIND_ABSOLUTE;
        else if (!strcmp(cJSON_GetStringValue(j), "Recurring")) x = CHARGINGPROFILEKIND_RECURRING;
        else if (!strcmp(cJSON_GetStringValue(j), "Relative")) x = CHARGINGPROFILEKIND_RELATIVE;
    }
    return x;
}

static cJSON * cJSON_CreateChargingProfileKind(const enum ChargingProfileKind x) {
    cJSON * j = NULL;
    switch (x) {
        case CHARGINGPROFILEKIND_ABSOLUTE: j = cJSON_CreateString("Absolute"); break;
        case CHARGINGPROFILEKIND_RECURRING: j = cJSON_CreateString("Recurring"); break;
        case CHARGINGPROFILEKIND_RELATIVE: j = cJSON_CreateString("Relative"); break;
    }
    return j;
}

static enum ChargingProfilePurpose cJSON_GetChargingProfilePurposeValue(const cJSON * j) {
    enum ChargingProfilePurpose x = 0;
    if (NULL != j) {
        if (!strcmp(cJSON_GetStringValue(j), "ChargePointMaxProfile")) x = CHARGINGPROFILEPURPOSE_CHARGE_POINT_MAX_PROFILE;
        else if (!strcmp(cJSON_GetStringValue(j), "TxDefaultProfile")) x = CHARGINGPROFILEPURPOSE_TX_DEFAULT_PROFILE;
        else if (!strcmp(cJSON_GetStringValue(j), "TxProfile")) x = CHARGINGPROFILEPURPOSE_TX_PROFILE;
    }
    return x;
}

static cJSON * cJSON_CreateChargingProfilePurpose(const enum ChargingProfilePurpose x) {
    cJSON * j = NULL;
    switch (x) {
        case CHARGINGPROFILEPURPOSE_CHARGE_POINT_MAX_PROFILE: j = cJSON_CreateString("ChargePointMaxProfile"); break;
        case CHARGINGPROFILEPURPOSE_TX_DEFAULT_PROFILE: j = cJSON_CreateString("TxDefaultProfile"); break;
        case CHARGINGPROFILEPURPOSE_TX_PROFILE: j = cJSON_CreateString("TxProfile"); break;
    }
    return j;
}

static enum ChargingRateUnit cJSON_GetChargingRateUnitValue(const cJSON * j) {
    enum ChargingRateUnit x = 0;
    if (NULL != j) {
        if (!strcmp(cJSON_GetStringValue(j), "A")) x = CHARGINGRATEUNIT_A;
        else if (!strcmp(cJSON_GetStringValue(j), "W")) x = CHARGINGRATEUNIT_W;
    }
    return x;
}

static cJSON * cJSON_CreateChargingRateUnit(const enum ChargingRateUnit x) {
    cJSON * j = NULL;
    switch (x) {
        case CHARGINGRATEUNIT_A: j = cJSON_CreateString("A"); break;
        case CHARGINGRATEUNIT_W: j = cJSON_CreateString("W"); break;
    }
    return j;
}

static enum RecurrencyKind cJSON_GetRecurrencyKindValue(const cJSON * j) {
    enum RecurrencyKind x = 0;
    if (NULL != j) {
        if (!strcmp(cJSON_GetStringValue(j), "Daily")) x = RECURRENCYKIND_DAILY;
        else if (!strcmp(cJSON_GetStringValue(j), "Weekly")) x = RECURRENCYKIND_WEEKLY;
    }
    return x;
}

static cJSON * cJSON_CreateRecurrencyKind(const enum RecurrencyKind x) {
    cJSON * j = NULL;
    switch (x) {
        case RECURRENCYKIND_DAILY: j = cJSON_CreateString("Daily"); break;
        case RECURRENCYKIND_WEEKLY: j = cJSON_CreateString("Weekly"); break;
    }
    return j;
}

struct ChargingSchedulePeriod * cJSON_ParseChargingSchedulePeriod(const char * s) {
    struct ChargingSchedulePeriod * x = NULL;
    if (NULL != s) {
        cJSON * j = cJSON_Parse(s);
        if (NULL != j) {
            x = cJSON_GetChargingSchedulePeriodValue(j);
            cJSON_Delete(j);
        }
    }
    return x;
}

static struct ChargingSchedulePeriod * cJSON_GetChargingSchedulePeriodValue(const cJSON * j) {
    struct ChargingSchedulePeriod * x = NULL;
    if (NULL != j) {
        if (NULL != (x = cJSON_malloc(sizeof(struct ChargingSchedulePeriod)))) {
            memset(x, 0, sizeof(struct ChargingSchedulePeriod));
            if (cJSON_HasObjectItem(j, "limit")) {
                x->limit = cJSON_GetNumberValue(cJSON_GetObjectItemCaseSensitive(j, "limit"));
            }
            if (cJSON_HasObjectItem(j, "numberPhases")) {
                if (NULL != (x->number_phases = cJSON_malloc(sizeof(int64_t)))) {
                    *x->number_phases = cJSON_GetNumberValue(cJSON_GetObjectItemCaseSensitive(j, "numberPhases"));
                }
            }
            if (cJSON_HasObjectItem(j, "startPeriod")) {
                x->start_period = cJSON_GetNumberValue(cJSON_GetObjectItemCaseSensitive(j, "startPeriod"));
            }
        }
    }
    return x;
}

static cJSON * cJSON_CreateChargingSchedulePeriod(const struct ChargingSchedulePeriod * x) {
    cJSON * j = NULL;
    if (NULL != x) {
        if (NULL != (j = cJSON_CreateObject())) {
            cJSON_AddNumberToObject(j, "limit", x->limit);
            if (NULL != x->number_phases) {
                cJSON_AddNumberToObject(j, "numberPhases", *x->number_phases);
            }
            cJSON_AddNumberToObject(j, "startPeriod", x->start_period);
        }
    }
    return j;
}

char * cJSON_PrintChargingSchedulePeriod(const struct ChargingSchedulePeriod * x) {
    char * s = NULL;
    if (NULL != x) {
        cJSON * j = cJSON_CreateChargingSchedulePeriod(x);
        if (NULL != j) {
            s = cJSON_Print(j);
            cJSON_Delete(j);
        }
    }
    return s;
}

static void cJSON_DeleteChargingSchedulePeriod(struct ChargingSchedulePeriod * x) {
    if (NULL != x) {
        if (NULL != x->number_phases) {
            cJSON_free(x->number_phases);
        }
        cJSON_free(x);
    }
}

struct ChargingSchedule * cJSON_ParseChargingSchedule(const char * s) {
    struct ChargingSchedule * x = NULL;
    if (NULL != s) {
        cJSON * j = cJSON_Parse(s);
        if (NULL != j) {
            x = cJSON_GetChargingScheduleValue(j);
            cJSON_Delete(j);
        }
    }
    return x;
}

static struct ChargingSchedule * cJSON_GetChargingScheduleValue(const cJSON * j) {
    struct ChargingSchedule * x = NULL;
    if (NULL != j) {
        if (NULL != (x = cJSON_malloc(sizeof(struct ChargingSchedule)))) {
            memset(x, 0, sizeof(struct ChargingSchedule));
            if (cJSON_HasObjectItem(j, "chargingRateUnit")) {
                x->charging_rate_unit = cJSON_GetChargingRateUnitValue(cJSON_GetObjectItemCaseSensitive(j, "chargingRateUnit"));
            }
            if (cJSON_HasObjectItem(j, "chargingSchedulePeriod")) {
                list_t * x1 = list_create(false, NULL);
                if (NULL != x1) {
                    cJSON * e1 = NULL;
                    cJSON * j1 = cJSON_GetObjectItemCaseSensitive(j, "chargingSchedulePeriod");
                    cJSON_ArrayForEach(e1, j1) {
                        list_add_tail(x1, cJSON_GetChargingSchedulePeriodValue(e1), sizeof(struct ChargingSchedulePeriod *));
                    }
                    x->charging_schedule_period = x1;
                }
            }
            else {
                x->charging_schedule_period = list_create(false, NULL);
            }
            if (cJSON_HasObjectItem(j, "duration")) {
                if (NULL != (x->duration = cJSON_malloc(sizeof(int64_t)))) {
                    *x->duration = cJSON_GetNumberValue(cJSON_GetObjectItemCaseSensitive(j, "duration"));
                }
            }
            if (cJSON_HasObjectItem(j, "minChargingRate")) {
                if (NULL != (x->min_charging_rate = cJSON_malloc(sizeof(double)))) {
                    *x->min_charging_rate = cJSON_GetNumberValue(cJSON_GetObjectItemCaseSensitive(j, "minChargingRate"));
                }
            }
            if (cJSON_HasObjectItem(j, "startSchedule")) {
                x->start_schedule = mystrdup(cJSON_GetStringValue(cJSON_GetObjectItemCaseSensitive(j, "startSchedule")));
            }
        }
    }
    return x;
}

static cJSON * cJSON_CreateChargingSchedule(const struct ChargingSchedule * x) {
    cJSON * j = NULL;
    if (NULL != x) {
        if (NULL != (j = cJSON_CreateObject())) {
            cJSON_AddItemToObject(j, "chargingRateUnit", cJSON_CreateChargingRateUnit(x->charging_rate_unit));
            if (NULL != x->charging_schedule_period) {
                cJSON * j1 = cJSON_AddArrayToObject(j, "chargingSchedulePeriod");
                if (NULL != j1) {
                    struct ChargingSchedulePeriod * x1 = list_get_head(x->charging_schedule_period);
                    while (NULL != x1) {
                        cJSON_AddItemToArray(j1, cJSON_CreateChargingSchedulePeriod(x1));
                        x1 = list_get_next(x->charging_schedule_period);
                    }
                }
            }
            if (NULL != x->duration) {
                cJSON_AddNumberToObject(j, "duration", *x->duration);
            }
            if (NULL != x->min_charging_rate) {
                cJSON_AddNumberToObject(j, "minChargingRate", *x->min_charging_rate);
            }
            if (NULL != x->start_schedule) {
                cJSON_AddStringToObject(j, "startSchedule", x->start_schedule);
            }
        }
    }
    return j;
}

char * cJSON_PrintChargingSchedule(const struct ChargingSchedule * x) {
    char * s = NULL;
    if (NULL != x) {
        cJSON * j = cJSON_CreateChargingSchedule(x);
        if (NULL != j) {
            s = cJSON_Print(j);
            cJSON_Delete(j);
        }
    }
    return s;
}

static void cJSON_DeleteChargingSchedule(struct ChargingSchedule * x) {
    if (NULL != x) {
        if (NULL != x->charging_schedule_period) {
            struct ChargingSchedulePeriod * x1 = list_get_head(x->charging_schedule_period);
            while (NULL != x1) {
                cJSON_DeleteChargingSchedulePeriod(x1);
                x1 = list_get_next(x->charging_schedule_period);
            }
            list_release(x->charging_schedule_period);
        }
        if (NULL != x->duration) {
            cJSON_free(x->duration);
        }
        if (NULL != x->min_charging_rate) {
            cJSON_free(x->min_charging_rate);
        }
        if (NULL != x->start_schedule) {
            cJSON_free(x->start_schedule);
        }
        cJSON_free(x);
    }
}

struct ChargingProfile * cJSON_ParseChargingProfile(const char * s) {
    struct ChargingProfile * x = NULL;
    if (NULL != s) {
        cJSON * j = cJSON_Parse(s);
        if (NULL != j) {
            x = cJSON_GetChargingProfileValue(j);
            cJSON_Delete(j);
        }
    }
    return x;
}

static struct ChargingProfile * cJSON_GetChargingProfileValue(const cJSON * j) {
    struct ChargingProfile * x = NULL;
    if (NULL != j) {
        if (NULL != (x = cJSON_malloc(sizeof(struct ChargingProfile)))) {
            memset(x, 0, sizeof(struct ChargingProfile));
            if (cJSON_HasObjectItem(j, "chargingProfileId")) {
                x->charging_profile_id = cJSON_GetNumberValue(cJSON_GetObjectItemCaseSensitive(j, "chargingProfileId"));
            }
            if (cJSON_HasObjectItem(j, "chargingProfileKind")) {
                x->charging_profile_kind = cJSON_GetChargingProfileKindValue(cJSON_GetObjectItemCaseSensitive(j, "chargingProfileKind"));
            }
            if (cJSON_HasObjectItem(j, "chargingProfilePurpose")) {
                x->charging_profile_purpose = cJSON_GetChargingProfilePurposeValue(cJSON_GetObjectItemCaseSensitive(j, "chargingProfilePurpose"));
            }
            if (cJSON_HasObjectItem(j, "chargingSchedule")) {
                x->charging_schedule = cJSON_GetChargingScheduleValue(cJSON_GetObjectItemCaseSensitive(j, "chargingSchedule"));
            }
            if (cJSON_HasObjectItem(j, "recurrencyKind")) {
                if (NULL != (x->recurrency_kind = cJSON_malloc(sizeof(enum RecurrencyKind)))) {
                    *x->recurrency_kind = cJSON_GetRecurrencyKindValue(cJSON_GetObjectItemCaseSensitive(j, "recurrencyKind"));
                }
            }
            if (cJSON_HasObjectItem(j, "stackLevel")) {
                x->stack_level = cJSON_GetNumberValue(cJSON_GetObjectItemCaseSensitive(j, "stackLevel"));
            }
            if (cJSON_HasObjectItem(j, "transactionId")) {
                if (NULL != (x->transaction_id = cJSON_malloc(sizeof(int64_t)))) {
                    *x->transaction_id = cJSON_GetNumberValue(cJSON_GetObjectItemCaseSensitive(j, "transactionId"));
                }
            }
            if (cJSON_HasObjectItem(j, "validFrom")) {
                x->valid_from = mystrdup(cJSON_GetStringValue(cJSON_GetObjectItemCaseSensitive(j, "validFrom")));
            }
            if (cJSON_HasObjectItem(j, "validTo")) {
                x->valid_to = mystrdup(cJSON_GetStringValue(cJSON_GetObjectItemCaseSensitive(j, "validTo")));
            }
        }
    }
    return x;
}

static cJSON * cJSON_CreateChargingProfile(const struct ChargingProfile * x) {
    cJSON * j = NULL;
    if (NULL != x) {
        if (NULL != (j = cJSON_CreateObject())) {
            cJSON_AddNumberToObject(j, "chargingProfileId", x->charging_profile_id);
            cJSON_AddItemToObject(j, "chargingProfileKind", cJSON_CreateChargingProfileKind(x->charging_profile_kind));
            cJSON_AddItemToObject(j, "chargingProfilePurpose", cJSON_CreateChargingProfilePurpose(x->charging_profile_purpose));
            cJSON_AddItemToObject(j, "chargingSchedule", cJSON_CreateChargingSchedule(x->charging_schedule));
            if (NULL != x->recurrency_kind) {
                cJSON_AddItemToObject(j, "recurrencyKind", cJSON_CreateRecurrencyKind(*x->recurrency_kind));
            }
            cJSON_AddNumberToObject(j, "stackLevel", x->stack_level);
            if (NULL != x->transaction_id) {
                cJSON_AddNumberToObject(j, "transactionId", *x->transaction_id);
            }
            if (NULL != x->valid_from) {
                cJSON_AddStringToObject(j, "validFrom", x->valid_from);
            }
            if (NULL != x->valid_to) {
                cJSON_AddStringToObject(j, "validTo", x->valid_to);
            }
        }
    }
    return j;
}

char * cJSON_PrintChargingProfile(const struct ChargingProfile * x) {
    char * s = NULL;
    if (NULL != x) {
        cJSON * j = cJSON_CreateChargingProfile(x);
        if (NULL != j) {
            s = cJSON_Print(j);
            cJSON_Delete(j);
        }
    }
    return s;
}

static void cJSON_DeleteChargingProfile(struct ChargingProfile * x) {
    if (NULL != x) {
        if (NULL != x->charging_schedule) {
            cJSON_DeleteChargingSchedule(x->charging_schedule);
        }
        if (NULL != x->recurrency_kind) {
            cJSON_free(x->recurrency_kind);
        }
        if (NULL != x->transaction_id) {
            cJSON_free(x->transaction_id);
        }
        if (NULL != x->valid_from) {
            cJSON_free(x->valid_from);
        }
        if (NULL != x->valid_to) {
            cJSON_free(x->valid_to);
        }
        cJSON_free(x);
    }
}

struct RemoteStartTransactionReq * cJSON_ParseRemoteStartTransactionReq(const char * s) {
    struct RemoteStartTransactionReq * x = NULL;
    if (NULL != s) {
        cJSON * j = cJSON_Parse(s);
        if (NULL != j) {
            x = cJSON_GetRemoteStartTransactionReqValue(j);
            cJSON_Delete(j);
        }
    }
    return x;
}

static struct RemoteStartTransactionReq * cJSON_GetRemoteStartTransactionReqValue(const cJSON * j) {
    struct RemoteStartTransactionReq * x = NULL;
    if (NULL != j) {
        if (NULL != (x = cJSON_malloc(sizeof(struct RemoteStartTransactionReq)))) {
            memset(x, 0, sizeof(struct RemoteStartTransactionReq));
            if (cJSON_HasObjectItem(j, "chargingProfile")) {
                x->charging_profile = cJSON_GetChargingProfileValue(cJSON_GetObjectItemCaseSensitive(j, "chargingProfile"));
            }
            if (cJSON_HasObjectItem(j, "connectorId")) {
                if (NULL != (x->connector_id = cJSON_malloc(sizeof(int64_t)))) {
                    *x->connector_id = cJSON_GetNumberValue(cJSON_GetObjectItemCaseSensitive(j, "connectorId"));
                }
            }
            if (cJSON_HasObjectItem(j, "idTag")) {
                x->id_tag = mystrdup(cJSON_GetStringValue(cJSON_GetObjectItemCaseSensitive(j, "idTag")));
            }
            else {
                if (NULL != (x->id_tag = cJSON_malloc(sizeof(char)))) {
                    x->id_tag[0] = '\0';
                }
            }
        }
    }
    return x;
}

static cJSON * cJSON_CreateRemoteStartTransactionReq(const struct RemoteStartTransactionReq * x) {
    cJSON * j = NULL;
    if (NULL != x) {
        if (NULL != (j = cJSON_CreateObject())) {
            if (NULL != x->charging_profile) {
                cJSON_AddItemToObject(j, "chargingProfile", cJSON_CreateChargingProfile(x->charging_profile));
            }
            if (NULL != x->connector_id) {
                cJSON_AddNumberToObject(j, "connectorId", *x->connector_id);
            }
            if (NULL != x->id_tag) {
                cJSON_AddStringToObject(j, "idTag", x->id_tag);
            }
            else {
                cJSON_AddStringToObject(j, "idTag", "");
            }
        }
    }
    return j;
}

char * cJSON_PrintRemoteStartTransactionReq(const struct RemoteStartTransactionReq * x) {
    char * s = NULL;
    if (NULL != x) {
        cJSON * j = cJSON_CreateRemoteStartTransactionReq(x);
        if (NULL != j) {
            s = cJSON_Print(j);
            cJSON_Delete(j);
        }
    }
    return s;
}

static void cJSON_DeleteRemoteStartTransactionReq(struct RemoteStartTransactionReq * x) {
    if (NULL != x) {
        if (NULL != x->charging_profile) {
            cJSON_DeleteChargingProfile(x->charging_profile);
        }
        if (NULL != x->connector_id) {
            cJSON_free(x->connector_id);
        }
        if (NULL != x->id_tag) {
            cJSON_free(x->id_tag);
        }
        cJSON_free(x);
    }
}

#ifdef __cplusplus
}
#endif

#endif /* __STDOUT__ */
