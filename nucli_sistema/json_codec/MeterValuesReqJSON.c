/**
 * stdout
 * This file has been autogenerated using quicktype https://github.com/quicktype/quicktype - DO NOT EDIT
 * This file depends of https://github.com/DaveGamble/cJSON, https://github.com/joelguittet/c-list and https://github.com/joelguittet/c-hashtable
 * To parse json data from json string use the following: struct <type> * data = cJSON_Parse<type>(<string>);
 * To get json data from cJSON object use the following: struct <type> * data = cJSON_Get<type>Value(<cjson>);
 * To get cJSON object from json data use the following: cJSON * cjson = cJSON_Create<type>(<data>);
 * To print json string from json data use the following: char * string = cJSON_Print<type>(<data>);
 * To delete json data use the following: cJSON_Delete<type>(<data>);
 */

#ifndef __STDOUT__
#define __STDOUT__

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <cJSON.h>
#include <hashtable.h>
#include <list.h>
#include "MeterValuesReqJSON.h"
#include "mystrdup.h"

#ifndef cJSON_Bool
#define cJSON_Bool (cJSON_True | cJSON_False)
#endif
#ifndef cJSON_Map
#define cJSON_Map (1 << 16)
#endif
#ifndef cJSON_Enum
#define cJSON_Enum (1 << 17)
#endif

static enum Context cJSON_GetContextValue(const cJSON * j);
static cJSON * cJSON_CreateContext(const enum Context x);

static enum Format cJSON_GetFormatValue(const cJSON * j);
static cJSON * cJSON_CreateFormat(const enum Format x);

static enum Location cJSON_GetLocationValue(const cJSON * j);
static cJSON * cJSON_CreateLocation(const enum Location x);

static enum Measurand cJSON_GetMeasurandValue(const cJSON * j);
static cJSON * cJSON_CreateMeasurand(const enum Measurand x);

static enum Phase cJSON_GetPhaseValue(const cJSON * j);
static cJSON * cJSON_CreatePhase(const enum Phase x);

static enum Unit cJSON_GetUnitValue(const cJSON * j);
static cJSON * cJSON_CreateUnit(const enum Unit x);

static struct SampledValue * cJSON_GetSampledValueValue(const cJSON * j);
static cJSON * cJSON_CreateSampledValue(const struct SampledValue * x);
static char * cJSON_PrintSampledValue(const struct SampledValue * x);
static void cJSON_DeleteSampledValue(struct SampledValue * x);

static struct MeterValue * cJSON_GetMeterValueValue(const cJSON * j);
static cJSON * cJSON_CreateMeterValue(const struct MeterValue * x);
static char * cJSON_PrintMeterValue(const struct MeterValue * x);
static void cJSON_DeleteMeterValue(struct MeterValue * x);

static struct MeterValuesReq * cJSON_GetMeterValuesReqValue(const cJSON * j);
static cJSON * cJSON_CreateMeterValuesReq(const struct MeterValuesReq * x);
static void cJSON_DeleteMeterValuesReq(struct MeterValuesReq * x);

// Modificació: afegeixo l'else de x = -1 i x = -2
static enum Context cJSON_GetContextValue(const cJSON * j) {
    enum Context x = 0;
    if (NULL != j) {
        if (cJSON_GetStringValue(j) != NULL) {
            if (!strcmp(cJSON_GetStringValue(j), "Interruption.Begin")) x = CONTEXT_INTERRUPTION_BEGIN;
            else if (!strcmp(cJSON_GetStringValue(j), "Interruption.End")) x = CONTEXT_INTERRUPTION_END;
            else if (!strcmp(cJSON_GetStringValue(j), "Other")) x = CONTEXT_OTHER;
            else if (!strcmp(cJSON_GetStringValue(j), "Sample.Clock")) x = CONTEXT_SAMPLE_CLOCK;
            else if (!strcmp(cJSON_GetStringValue(j), "Sample.Periodic")) x = CONTEXT_SAMPLE_PERIODIC;
            else if (!strcmp(cJSON_GetStringValue(j), "Transaction.Begin")) x = CONTEXT_TRANSACTION_BEGIN;
            else if (!strcmp(cJSON_GetStringValue(j), "Transaction.End")) x = CONTEXT_TRANSACTION_END;
            else if (!strcmp(cJSON_GetStringValue(j), "Trigger")) x = CONTEXT_TRIGGER;
            else x = -1;
        }
        else
            x = -2;
    }
    return x;
}

static cJSON * cJSON_CreateContext(const enum Context x) {
    cJSON * j = NULL;
    switch (x) {
        case CONTEXT_INTERRUPTION_BEGIN: j = cJSON_CreateString("Interruption.Begin"); break;
        case CONTEXT_INTERRUPTION_END: j = cJSON_CreateString("Interruption.End"); break;
        case CONTEXT_OTHER: j = cJSON_CreateString("Other"); break;
        case CONTEXT_SAMPLE_CLOCK: j = cJSON_CreateString("Sample.Clock"); break;
        case CONTEXT_SAMPLE_PERIODIC: j = cJSON_CreateString("Sample.Periodic"); break;
        case CONTEXT_TRANSACTION_BEGIN: j = cJSON_CreateString("Transaction.Begin"); break;
        case CONTEXT_TRANSACTION_END: j = cJSON_CreateString("Transaction.End"); break;
        case CONTEXT_TRIGGER: j = cJSON_CreateString("Trigger"); break;
    }
    return j;
}

// Modificació: afegeixo l'else de x = -1 i x = -2
static enum Format cJSON_GetFormatValue(const cJSON * j) {
    enum Format x = 0;
    if (NULL != j) {
        if (cJSON_GetStringValue(j) != NULL) {
            if (!strcmp(cJSON_GetStringValue(j), "Raw")) x = FORMAT_RAW;
            else if (!strcmp(cJSON_GetStringValue(j), "SignedData")) x = FORMAT_SIGNED_DATA;
            else x = -1;
        }
        else
            x = -2;
    }
    return x;
}

static cJSON * cJSON_CreateFormat(const enum Format x) {
    cJSON * j = NULL;
    switch (x) {
        case FORMAT_RAW: j = cJSON_CreateString("Raw"); break;
        case FORMAT_SIGNED_DATA: j = cJSON_CreateString("SignedData"); break;
    }
    return j;
}

// Modificació: afegeixo l'else de x = -1 i x = -2
static enum Location cJSON_GetLocationValue(const cJSON * j) {
    enum Location x = 0;
    if (NULL != j) {
        if (cJSON_GetStringValue(j) != NULL) {
            if (!strcmp(cJSON_GetStringValue(j), "Body")) x = LOCATION_BODY;
            else if (!strcmp(cJSON_GetStringValue(j), "Cable")) x = LOCATION_CABLE;
            else if (!strcmp(cJSON_GetStringValue(j), "EV")) x = LOCATION_EV;
            else if (!strcmp(cJSON_GetStringValue(j), "Inlet")) x = LOCATION_INLET;
            else if (!strcmp(cJSON_GetStringValue(j), "Outlet")) x = LOCATION_OUTLET;
            else x = -1;
        }
        else
            x = -2;
    }
    return x;
}

static cJSON * cJSON_CreateLocation(const enum Location x) {
    cJSON * j = NULL;
    switch (x) {
        case LOCATION_BODY: j = cJSON_CreateString("Body"); break;
        case LOCATION_CABLE: j = cJSON_CreateString("Cable"); break;
        case LOCATION_EV: j = cJSON_CreateString("EV"); break;
        case LOCATION_INLET: j = cJSON_CreateString("Inlet"); break;
        case LOCATION_OUTLET: j = cJSON_CreateString("Outlet"); break;
    }
    return j;
}

// Modificació: afegeixo l'else de x = -1 i x = -2
static enum Measurand cJSON_GetMeasurandValue(const cJSON * j) {
    enum Measurand x = 0;
    if (NULL != j) {
        if (cJSON_GetStringValue(j) != NULL) {
            if (!strcmp(cJSON_GetStringValue(j), "Current.Export")) x = MEASURAND_CURRENT_EXPORT;
            else if (!strcmp(cJSON_GetStringValue(j), "Current.Import")) x = MEASURAND_CURRENT_IMPORT;
            else if (!strcmp(cJSON_GetStringValue(j), "Current.Offered")) x = MEASURAND_CURRENT_OFFERED;
            else if (!strcmp(cJSON_GetStringValue(j), "Energy.Active.Export.Interval")) x = MEASURAND_ENERGY_ACTIVE_EXPORT_INTERVAL;
            else if (!strcmp(cJSON_GetStringValue(j), "Energy.Active.Export.Register")) x = MEASURAND_ENERGY_ACTIVE_EXPORT_REGISTER;
            else if (!strcmp(cJSON_GetStringValue(j), "Energy.Active.Import.Interval")) x = MEASURAND_ENERGY_ACTIVE_IMPORT_INTERVAL;
            else if (!strcmp(cJSON_GetStringValue(j), "Energy.Active.Import.Register")) x = MEASURAND_ENERGY_ACTIVE_IMPORT_REGISTER;
            else if (!strcmp(cJSON_GetStringValue(j), "Energy.Reactive.Export.Interval")) x = MEASURAND_ENERGY_REACTIVE_EXPORT_INTERVAL;
            else if (!strcmp(cJSON_GetStringValue(j), "Energy.Reactive.Export.Register")) x = MEASURAND_ENERGY_REACTIVE_EXPORT_REGISTER;
            else if (!strcmp(cJSON_GetStringValue(j), "Energy.Reactive.Import.Interval")) x = MEASURAND_ENERGY_REACTIVE_IMPORT_INTERVAL;
            else if (!strcmp(cJSON_GetStringValue(j), "Energy.Reactive.Import.Register")) x = MEASURAND_ENERGY_REACTIVE_IMPORT_REGISTER;
            else if (!strcmp(cJSON_GetStringValue(j), "Frequency")) x = MEASURAND_FREQUENCY;
            else if (!strcmp(cJSON_GetStringValue(j), "Power.Active.Export")) x = MEASURAND_POWER_ACTIVE_EXPORT;
            else if (!strcmp(cJSON_GetStringValue(j), "Power.Active.Import")) x = MEASURAND_POWER_ACTIVE_IMPORT;
            else if (!strcmp(cJSON_GetStringValue(j), "Power.Factor")) x = MEASURAND_POWER_FACTOR;
            else if (!strcmp(cJSON_GetStringValue(j), "Power.Offered")) x = MEASURAND_POWER_OFFERED;
            else if (!strcmp(cJSON_GetStringValue(j), "Power.Reactive.Export")) x = MEASURAND_POWER_REACTIVE_EXPORT;
            else if (!strcmp(cJSON_GetStringValue(j), "Power.Reactive.Import")) x = MEASURAND_POWER_REACTIVE_IMPORT;
            else if (!strcmp(cJSON_GetStringValue(j), "RPM")) x = MEASURAND_RPM;
            else if (!strcmp(cJSON_GetStringValue(j), "SoC")) x = MEASURAND_SO_C;
            else if (!strcmp(cJSON_GetStringValue(j), "Temperature")) x = MEASURAND_TEMPERATURE;
            else if (!strcmp(cJSON_GetStringValue(j), "Voltage")) x = MEASURAND_VOLTAGE;
            else x = -1;
        }
        else
            x = -2;
    }
    return x;
}

static cJSON * cJSON_CreateMeasurand(const enum Measurand x) {
    cJSON * j = NULL;
    switch (x) {
        case MEASURAND_CURRENT_EXPORT: j = cJSON_CreateString("Current.Export"); break;
        case MEASURAND_CURRENT_IMPORT: j = cJSON_CreateString("Current.Import"); break;
        case MEASURAND_CURRENT_OFFERED: j = cJSON_CreateString("Current.Offered"); break;
        case MEASURAND_ENERGY_ACTIVE_EXPORT_INTERVAL: j = cJSON_CreateString("Energy.Active.Export.Interval"); break;
        case MEASURAND_ENERGY_ACTIVE_EXPORT_REGISTER: j = cJSON_CreateString("Energy.Active.Export.Register"); break;
        case MEASURAND_ENERGY_ACTIVE_IMPORT_INTERVAL: j = cJSON_CreateString("Energy.Active.Import.Interval"); break;
        case MEASURAND_ENERGY_ACTIVE_IMPORT_REGISTER: j = cJSON_CreateString("Energy.Active.Import.Register"); break;
        case MEASURAND_ENERGY_REACTIVE_EXPORT_INTERVAL: j = cJSON_CreateString("Energy.Reactive.Export.Interval"); break;
        case MEASURAND_ENERGY_REACTIVE_EXPORT_REGISTER: j = cJSON_CreateString("Energy.Reactive.Export.Register"); break;
        case MEASURAND_ENERGY_REACTIVE_IMPORT_INTERVAL: j = cJSON_CreateString("Energy.Reactive.Import.Interval"); break;
        case MEASURAND_ENERGY_REACTIVE_IMPORT_REGISTER: j = cJSON_CreateString("Energy.Reactive.Import.Register"); break;
        case MEASURAND_FREQUENCY: j = cJSON_CreateString("Frequency"); break;
        case MEASURAND_POWER_ACTIVE_EXPORT: j = cJSON_CreateString("Power.Active.Export"); break;
        case MEASURAND_POWER_ACTIVE_IMPORT: j = cJSON_CreateString("Power.Active.Import"); break;
        case MEASURAND_POWER_FACTOR: j = cJSON_CreateString("Power.Factor"); break;
        case MEASURAND_POWER_OFFERED: j = cJSON_CreateString("Power.Offered"); break;
        case MEASURAND_POWER_REACTIVE_EXPORT: j = cJSON_CreateString("Power.Reactive.Export"); break;
        case MEASURAND_POWER_REACTIVE_IMPORT: j = cJSON_CreateString("Power.Reactive.Import"); break;
        case MEASURAND_RPM: j = cJSON_CreateString("RPM"); break;
        case MEASURAND_SO_C: j = cJSON_CreateString("SoC"); break;
        case MEASURAND_TEMPERATURE: j = cJSON_CreateString("Temperature"); break;
        case MEASURAND_VOLTAGE: j = cJSON_CreateString("Voltage"); break;
    }
    return j;
}

// Modificació: afegeixo l'else de x = -1 i x = -2
static enum Phase cJSON_GetPhaseValue(const cJSON * j) {
    enum Phase x = 0;
    if (NULL != j) {
        if (cJSON_GetStringValue(j) != NULL) {
            if (!strcmp(cJSON_GetStringValue(j), "L1")) x = PHASE_L1;
            else if (!strcmp(cJSON_GetStringValue(j), "L1-L2")) x = PHASE_L1_L2;
            else if (!strcmp(cJSON_GetStringValue(j), "L1-N")) x = PHASE_L1_N;
            else if (!strcmp(cJSON_GetStringValue(j), "L2")) x = PHASE_L2;
            else if (!strcmp(cJSON_GetStringValue(j), "L2-L3")) x = PHASE_L2_L3;
            else if (!strcmp(cJSON_GetStringValue(j), "L2-N")) x = PHASE_L2_N;
            else if (!strcmp(cJSON_GetStringValue(j), "L3")) x = PHASE_L3;
            else if (!strcmp(cJSON_GetStringValue(j), "L3-L1")) x = PHASE_L3_L1;
            else if (!strcmp(cJSON_GetStringValue(j), "L3-N")) x = PHASE_L3_N;
            else if (!strcmp(cJSON_GetStringValue(j), "N")) x = PHASE_N;
            else x = -1;
        }
        else
            x = -2;
    }
    return x;
}

static cJSON * cJSON_CreatePhase(const enum Phase x) {
    cJSON * j = NULL;
    switch (x) {
        case PHASE_L1: j = cJSON_CreateString("L1"); break;
        case PHASE_L1_L2: j = cJSON_CreateString("L1-L2"); break;
        case PHASE_L1_N: j = cJSON_CreateString("L1-N"); break;
        case PHASE_L2: j = cJSON_CreateString("L2"); break;
        case PHASE_L2_L3: j = cJSON_CreateString("L2-L3"); break;
        case PHASE_L2_N: j = cJSON_CreateString("L2-N"); break;
        case PHASE_L3: j = cJSON_CreateString("L3"); break;
        case PHASE_L3_L1: j = cJSON_CreateString("L3-L1"); break;
        case PHASE_L3_N: j = cJSON_CreateString("L3-N"); break;
        case PHASE_N: j = cJSON_CreateString("N"); break;
    }
    return j;
}

// Modificació: afegeixo l'else de x = -1 i x = -2
static enum Unit cJSON_GetUnitValue(const cJSON * j) {
    enum Unit x = 0;
    if (NULL != j) {
        if (cJSON_GetStringValue(j) != NULL) {
            if (!strcmp(cJSON_GetStringValue(j), "A")) x = UNIT_A;
            else if (!strcmp(cJSON_GetStringValue(j), "Celcius")) x = UNIT_CELCIUS;
            else if (!strcmp(cJSON_GetStringValue(j), "Celsius")) x = UNIT_CELSIUS;
            else if (!strcmp(cJSON_GetStringValue(j), "Fahrenheit")) x = UNIT_FAHRENHEIT;
            else if (!strcmp(cJSON_GetStringValue(j), "K")) x = UNIT_K;
            else if (!strcmp(cJSON_GetStringValue(j), "kvar")) x = UNIT_KVAR;
            else if (!strcmp(cJSON_GetStringValue(j), "kvarh")) x = UNIT_KVARH;
            else if (!strcmp(cJSON_GetStringValue(j), "kVA")) x = UNIT_K_VA;
            else if (!strcmp(cJSON_GetStringValue(j), "kW")) x = UNIT_K_W;
            else if (!strcmp(cJSON_GetStringValue(j), "kWh")) x = UNIT_K_WH;
            else if (!strcmp(cJSON_GetStringValue(j), "Percent")) x = UNIT_PERCENT;
            else if (!strcmp(cJSON_GetStringValue(j), "V")) x = UNIT_V;
            else if (!strcmp(cJSON_GetStringValue(j), "VA")) x = UNIT_VA;
            else if (!strcmp(cJSON_GetStringValue(j), "var")) x = UNIT_VAR;
            else if (!strcmp(cJSON_GetStringValue(j), "varh")) x = UNIT_VARH;
            else if (!strcmp(cJSON_GetStringValue(j), "W")) x = UNIT_W;
            else if (!strcmp(cJSON_GetStringValue(j), "Wh")) x = UNIT_WH;
            else x = -1;
        }
        else
            x = -2;
    }
    return x;
}

static cJSON * cJSON_CreateUnit(const enum Unit x) {
    cJSON * j = NULL;
    switch (x) {
        case UNIT_A: j = cJSON_CreateString("A"); break;
        case UNIT_CELCIUS: j = cJSON_CreateString("Celcius"); break;
        case UNIT_CELSIUS: j = cJSON_CreateString("Celsius"); break;
        case UNIT_FAHRENHEIT: j = cJSON_CreateString("Fahrenheit"); break;
        case UNIT_K: j = cJSON_CreateString("K"); break;
        case UNIT_KVAR: j = cJSON_CreateString("kvar"); break;
        case UNIT_KVARH: j = cJSON_CreateString("kvarh"); break;
        case UNIT_K_VA: j = cJSON_CreateString("kVA"); break;
        case UNIT_K_W: j = cJSON_CreateString("kW"); break;
        case UNIT_K_WH: j = cJSON_CreateString("kWh"); break;
        case UNIT_PERCENT: j = cJSON_CreateString("Percent"); break;
        case UNIT_V: j = cJSON_CreateString("V"); break;
        case UNIT_VA: j = cJSON_CreateString("VA"); break;
        case UNIT_VAR: j = cJSON_CreateString("var"); break;
        case UNIT_VARH: j = cJSON_CreateString("varh"); break;
        case UNIT_W: j = cJSON_CreateString("W"); break;
        case UNIT_WH: j = cJSON_CreateString("Wh"); break;
    }
    return j;
}

struct SampledValue * cJSON_ParseSampledValue(const char * s) {
    struct SampledValue * x = NULL;
    if (NULL != s) {
        cJSON * j = cJSON_Parse(s);
        if (NULL != j) {
            x = cJSON_GetSampledValueValue(j);
            cJSON_Delete(j);
        }
    }
    return x;
}

static struct SampledValue * cJSON_GetSampledValueValue(const cJSON * j) {
    struct SampledValue * x = NULL;
    if (NULL != j) {
        if (NULL != (x = cJSON_malloc(sizeof(struct SampledValue)))) {
            memset(x, 0, sizeof(struct SampledValue));
            if (cJSON_HasObjectItem(j, "context")) {
                if (NULL != (x->context = cJSON_malloc(sizeof(enum Context)))) {
                    *x->context = cJSON_GetContextValue(cJSON_GetObjectItemCaseSensitive(j, "context"));
                }
            }
            if (cJSON_HasObjectItem(j, "format")) {
                if (NULL != (x->format = cJSON_malloc(sizeof(enum Format)))) {
                    *x->format = cJSON_GetFormatValue(cJSON_GetObjectItemCaseSensitive(j, "format"));
                }
            }
            if (cJSON_HasObjectItem(j, "location")) {
                if (NULL != (x->location = cJSON_malloc(sizeof(enum Location)))) {
                    *x->location = cJSON_GetLocationValue(cJSON_GetObjectItemCaseSensitive(j, "location"));
                }
            }
            if (cJSON_HasObjectItem(j, "measurand")) {
                if (NULL != (x->measurand = cJSON_malloc(sizeof(enum Measurand)))) {
                    *x->measurand = cJSON_GetMeasurandValue(cJSON_GetObjectItemCaseSensitive(j, "measurand"));
                }
            }
            if (cJSON_HasObjectItem(j, "phase")) {
                if (NULL != (x->phase = cJSON_malloc(sizeof(enum Phase)))) {
                    *x->phase = cJSON_GetPhaseValue(cJSON_GetObjectItemCaseSensitive(j, "phase"));
                }
            }
            if (cJSON_HasObjectItem(j, "unit")) {
                if (NULL != (x->unit = cJSON_malloc(sizeof(enum Unit)))) {
                    *x->unit = cJSON_GetUnitValue(cJSON_GetObjectItemCaseSensitive(j, "unit"));
                }
            }
            if (cJSON_HasObjectItem(j, "value")) {
                x->value = mystrdup(cJSON_GetStringValue(cJSON_GetObjectItemCaseSensitive(j, "value")));
            }
            else {
                if (NULL != (x->value = cJSON_malloc(sizeof(char)))) {
                    x->value[0] = '\0';
                }
            }
        }
    }
    return x;
}

static cJSON * cJSON_CreateSampledValue(const struct SampledValue * x) {
    cJSON * j = NULL;
    if (NULL != x) {
        if (NULL != (j = cJSON_CreateObject())) {
            if (NULL != x->context) {
                cJSON_AddItemToObject(j, "context", cJSON_CreateContext(*x->context));
            }
            if (NULL != x->format) {
                cJSON_AddItemToObject(j, "format", cJSON_CreateFormat(*x->format));
            }
            if (NULL != x->location) {
                cJSON_AddItemToObject(j, "location", cJSON_CreateLocation(*x->location));
            }
            if (NULL != x->measurand) {
                cJSON_AddItemToObject(j, "measurand", cJSON_CreateMeasurand(*x->measurand));
            }
            if (NULL != x->phase) {
                cJSON_AddItemToObject(j, "phase", cJSON_CreatePhase(*x->phase));
            }
            if (NULL != x->unit) {
                cJSON_AddItemToObject(j, "unit", cJSON_CreateUnit(*x->unit));
            }
            if (NULL != x->value) {
                cJSON_AddStringToObject(j, "value", x->value);
            }
            else {
                cJSON_AddStringToObject(j, "value", "");
            }
        }
    }
    return j;
}

static char * cJSON_PrintSampledValue(const struct SampledValue * x) {
    char * s = NULL;
    if (NULL != x) {
        cJSON * j = cJSON_CreateSampledValue(x);
        if (NULL != j) {
            s = cJSON_Print(j);
            cJSON_Delete(j);
        }
    }
    return s;
}

static void cJSON_DeleteSampledValue(struct SampledValue * x) {
    if (NULL != x) {
        if (NULL != x->context) {
            cJSON_free(x->context);
        }
        if (NULL != x->format) {
            cJSON_free(x->format);
        }
        if (NULL != x->location) {
            cJSON_free(x->location);
        }
        if (NULL != x->measurand) {
            cJSON_free(x->measurand);
        }
        if (NULL != x->phase) {
            cJSON_free(x->phase);
        }
        if (NULL != x->unit) {
            cJSON_free(x->unit);
        }
        if (NULL != x->value) {
            cJSON_free(x->value);
        }
        cJSON_free(x);
    }
}

struct MeterValue * cJSON_ParseMeterValue(const char * s) {
    struct MeterValue * x = NULL;
    if (NULL != s) {
        cJSON * j = cJSON_Parse(s);
        if (NULL != j) {
            x = cJSON_GetMeterValueValue(j);
            cJSON_Delete(j);
        }
    }
    return x;
}

static struct MeterValue * cJSON_GetMeterValueValue(const cJSON * j) {
    struct MeterValue * x = NULL;
    if (NULL != j) {
        if (NULL != (x = cJSON_malloc(sizeof(struct MeterValue)))) {
            memset(x, 0, sizeof(struct MeterValue));
            if (cJSON_HasObjectItem(j, "sampledValue")) {
                list_t * x1 = list_create(false, NULL);
                if (NULL != x1) {
                    cJSON * e1 = NULL;
                    cJSON * j1 = cJSON_GetObjectItemCaseSensitive(j, "sampledValue");
                    cJSON_ArrayForEach(e1, j1) {
                        list_add_tail(x1, cJSON_GetSampledValueValue(e1), sizeof(struct SampledValue *));
                    }
                    x->sampled_value = x1;
                }
            }
            else {
                x->sampled_value = list_create(false, NULL);
            }
            if (cJSON_HasObjectItem(j, "timestamp")) {
                x->timestamp = mystrdup(cJSON_GetStringValue(cJSON_GetObjectItemCaseSensitive(j, "timestamp")));
            }
            else {
                if (NULL != (x->timestamp = cJSON_malloc(sizeof(char)))) {
                    x->timestamp[0] = '\0';
                }
            }
        }
    }
    return x;
}

static cJSON * cJSON_CreateMeterValue(const struct MeterValue * x) {
    cJSON * j = NULL;
    if (NULL != x) {
        if (NULL != (j = cJSON_CreateObject())) {
            if (NULL != x->sampled_value) {
                cJSON * j1 = cJSON_AddArrayToObject(j, "sampledValue");
                if (NULL != j1) {
                    struct SampledValue * x1 = list_get_head(x->sampled_value);
                    while (NULL != x1) {
                        cJSON_AddItemToArray(j1, cJSON_CreateSampledValue(x1));
                        x1 = list_get_next(x->sampled_value);
                    }
                }
            }
            if (NULL != x->timestamp) {
                cJSON_AddStringToObject(j, "timestamp", x->timestamp);
            }
            else {
                cJSON_AddStringToObject(j, "timestamp", "");
            }
        }
    }
    return j;
}

static char * cJSON_PrintMeterValue(const struct MeterValue * x) {
    char * s = NULL;
    if (NULL != x) {
        cJSON * j = cJSON_CreateMeterValue(x);
        if (NULL != j) {
            s = cJSON_Print(j);
            cJSON_Delete(j);
        }
    }
    return s;
}

static void cJSON_DeleteMeterValue(struct MeterValue * x) {
    if (NULL != x) {
        if (NULL != x->sampled_value) {
            struct SampledValue * x1 = list_get_head(x->sampled_value);
            while (NULL != x1) {
                cJSON_DeleteSampledValue(x1);
                x1 = list_get_next(x->sampled_value);
            }
            list_release(x->sampled_value);
        }
        if (NULL != x->timestamp) {
            cJSON_free(x->timestamp);
        }
        cJSON_free(x);
    }
}

struct MeterValuesReq * cJSON_ParseMeterValuesReq(const char * s) {
    struct MeterValuesReq * x = NULL;
    if (NULL != s) {
        cJSON * j = cJSON_Parse(s);
        if (NULL != j) {
            x = cJSON_GetMeterValuesReqValue(j);
            cJSON_Delete(j);
        }
    }
    return x;
}

// Modificació: afegit l'else posant connector_id = -1 en cas que no hi sigui
static struct MeterValuesReq * cJSON_GetMeterValuesReqValue(const cJSON * j) {
    struct MeterValuesReq * x = NULL;
    if (NULL != j) {
        if (NULL != (x = cJSON_malloc(sizeof(struct MeterValuesReq)))) {
            memset(x, 0, sizeof(struct MeterValuesReq));
            if (cJSON_HasObjectItem(j, "connectorId")) {
                x->connector_id = cJSON_GetNumberValue(cJSON_GetObjectItemCaseSensitive(j, "connectorId"));
            }
            else
                x->connector_id = -1;

            if (cJSON_HasObjectItem(j, "meterValue")) {
                list_t * x1 = list_create(false, NULL);
                if (NULL != x1) {
                    cJSON * e1 = NULL;
                    cJSON * j1 = cJSON_GetObjectItemCaseSensitive(j, "meterValue");
                    cJSON_ArrayForEach(e1, j1) {
                        list_add_tail(x1, cJSON_GetMeterValueValue(e1), sizeof(struct MeterValue *));
                    }
                    x->meter_value = x1;
                }
            }
            else {
                x->meter_value = list_create(false, NULL);
            }
            if (cJSON_HasObjectItem(j, "transactionId")) {
                if (NULL != (x->transaction_id = cJSON_malloc(sizeof(int64_t)))) {
                    *x->transaction_id = cJSON_GetNumberValue(cJSON_GetObjectItemCaseSensitive(j, "transactionId"));
                }
            }
        }
    }
    return x;
}

static cJSON * cJSON_CreateMeterValuesReq(const struct MeterValuesReq * x) {
    cJSON * j = NULL;
    if (NULL != x) {
        if (NULL != (j = cJSON_CreateObject())) {
            cJSON_AddNumberToObject(j, "connectorId", x->connector_id);
            if (NULL != x->meter_value) {
                cJSON * j1 = cJSON_AddArrayToObject(j, "meterValue");
                if (NULL != j1) {
                    struct MeterValue * x1 = list_get_head(x->meter_value);
                    while (NULL != x1) {
                        cJSON_AddItemToArray(j1, cJSON_CreateMeterValue(x1));
                        x1 = list_get_next(x->meter_value);
                    }
                }
            }
            if (NULL != x->transaction_id) {
                cJSON_AddNumberToObject(j, "transactionId", *x->transaction_id);
            }
        }
    }
    return j;
}

char * cJSON_PrintMeterValuesReq(const struct MeterValuesReq * x) {
    char * s = NULL;
    if (NULL != x) {
        cJSON * j = cJSON_CreateMeterValuesReq(x);
        if (NULL != j) {
            s = cJSON_Print(j);
            cJSON_Delete(j);
        }
    }
    return s;
}

static void cJSON_DeleteMeterValuesReq(struct MeterValuesReq * x) {
    if (NULL != x) {
        if (NULL != x->meter_value) {
            struct MeterValue * x1 = list_get_head(x->meter_value);
            while (NULL != x1) {
                cJSON_DeleteMeterValue(x1);
                x1 = list_get_next(x->meter_value);
            }
            list_release(x->meter_value);
        }
        if (NULL != x->transaction_id) {
            cJSON_free(x->transaction_id);
        }
        cJSON_free(x);
    }
}

#ifdef __cplusplus
}
#endif

#endif /* __STDOUT__ */
