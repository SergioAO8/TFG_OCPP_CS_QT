/**
 * stdout
 * This file has been autogenerated using quicktype https://github.com/quicktype/quicktype - DO NOT EDIT
 * This file depends of https://github.com/DaveGamble/cJSON, https://github.com/joelguittet/c-list and https://github.com/joelguittet/c-hashtable
 * To parse json data from json string use the following: struct <type> * data = cJSON_Parse<type>(<string>);
 * To get json data from cJSON object use the following: struct <type> * data = cJSON_Get<type>Value(<cjson>);
 * To get cJSON object from json data use the following: cJSON * cjson = cJSON_Create<type>(<data>);
 * To print json string from json data use the following: char * string = cJSON_Print<type>(<data>);
 * To delete json data use the following: cJSON_Delete<type>(<data>);
 */

#ifndef __STDOUT__
#define __STDOUT__

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <cJSON.h>
#include <hashtable.h>
#include <list.h>
#include "StopTransactionReqJSON.h"
#include "mystrdup.h"

#ifndef cJSON_Bool
#define cJSON_Bool (cJSON_True | cJSON_False)
#endif
#ifndef cJSON_Map
#define cJSON_Map (1 << 16)
#endif
#ifndef cJSON_Enum
#define cJSON_Enum (1 << 17)
#endif

static enum Reason cJSON_GetReasonValue(const cJSON * j);
static cJSON * cJSON_CreateReason(const enum Reason x);

static enum Context_Stop cJSON_GetContextValue(const cJSON * j);
static cJSON * cJSON_CreateContext(const enum Context_Stop x);

static enum Format_Stop cJSON_GetFormatValue(const cJSON * j);
static cJSON * cJSON_CreateFormat(const enum Format_Stop x);

static enum Location_Stop cJSON_GetLocationValue(const cJSON * j);
static cJSON * cJSON_CreateLocation(const enum Location_Stop x);

static enum Measurand_Stop cJSON_GetMeasurandValue(const cJSON * j);
static cJSON * cJSON_CreateMeasurand(const enum Measurand_Stop x);

static enum Phase_Stop cJSON_GetPhaseValue(const cJSON * j);
static cJSON * cJSON_CreatePhase(const enum Phase_Stop x);

static enum Unit_Stop cJSON_GetUnitValue(const cJSON * j);
static cJSON * cJSON_CreateUnit(const enum Unit_Stop x);

static struct SampledValue_Stop * cJSON_ParseSampledValue(const char * s);
static struct SampledValue_Stop * cJSON_GetSampledValueValue(const cJSON * j);
static cJSON * cJSON_CreateSampledValue(const struct SampledValue_Stop * x);
static char * cJSON_PrintSampledValue(const struct SampledValue_Stop * x);
static void cJSON_DeleteSampledValue(struct SampledValue_Stop * x);

static struct TransactionDatum * cJSON_ParseTransactionDatum(const char * s);
static struct TransactionDatum * cJSON_GetTransactionDatumValue(const cJSON * j);
static cJSON * cJSON_CreateTransactionDatum(const struct TransactionDatum * x);
static char * cJSON_PrintTransactionDatum(const struct TransactionDatum * x);
static void cJSON_DeleteTransactionDatum(struct TransactionDatum * x);

static struct StopTransactionReq * cJSON_GetStopTransactionReqValue(const cJSON * j);
static cJSON * cJSON_CreateStopTransactionReq(const struct StopTransactionReq * x);
static void cJSON_DeleteStopTransactionReq(struct StopTransactionReq * x);

// Modificació: afegeixo l'else de x = -1 i x = -2
static enum Reason cJSON_GetReasonValue(const cJSON * j) {
    enum Reason x = 0;
    if (NULL != j) {
        if (cJSON_GetStringValue(j) != NULL) {
            if (!strcmp(cJSON_GetStringValue(j), "DeAuthorized")) x = REASON_DE_AUTHORIZED;
            else if (!strcmp(cJSON_GetStringValue(j), "EmergencyStop")) x = REASON_EMERGENCY_STOP;
            else if (!strcmp(cJSON_GetStringValue(j), "EVDisconnected")) x = REASON_EV_DISCONNECTED;
            else if (!strcmp(cJSON_GetStringValue(j), "HardReset")) x = REASON_HARD_RESET;
            else if (!strcmp(cJSON_GetStringValue(j), "Local")) x = REASON_LOCAL;
            else if (!strcmp(cJSON_GetStringValue(j), "Other")) x = REASON_OTHER;
            else if (!strcmp(cJSON_GetStringValue(j), "PowerLoss")) x = REASON_POWER_LOSS;
            else if (!strcmp(cJSON_GetStringValue(j), "Reboot")) x = REASON_REBOOT;
            else if (!strcmp(cJSON_GetStringValue(j), "Remote")) x = REASON_REMOTE;
            else if (!strcmp(cJSON_GetStringValue(j), "SoftReset")) x = REASON_SOFT_RESET;
            else if (!strcmp(cJSON_GetStringValue(j), "UnlockCommand")) x = REASON_UNLOCK_COMMAND;
            else x = -1;
        }
        else
            x = -2;
    }
    return x;
}

static cJSON * cJSON_CreateReason(const enum Reason x) {
    cJSON * j = NULL;
    switch (x) {
        case REASON_DE_AUTHORIZED: j = cJSON_CreateString("DeAuthorized"); break;
        case REASON_EMERGENCY_STOP: j = cJSON_CreateString("EmergencyStop"); break;
        case REASON_EV_DISCONNECTED: j = cJSON_CreateString("EVDisconnected"); break;
        case REASON_HARD_RESET: j = cJSON_CreateString("HardReset"); break;
        case REASON_LOCAL: j = cJSON_CreateString("Local"); break;
        case REASON_OTHER: j = cJSON_CreateString("Other"); break;
        case REASON_POWER_LOSS: j = cJSON_CreateString("PowerLoss"); break;
        case REASON_REBOOT: j = cJSON_CreateString("Reboot"); break;
        case REASON_REMOTE: j = cJSON_CreateString("Remote"); break;
        case REASON_SOFT_RESET: j = cJSON_CreateString("SoftReset"); break;
        case REASON_UNLOCK_COMMAND: j = cJSON_CreateString("UnlockCommand"); break;
    }
    return j;
}

// Modificació: afegeixo l'else de x = -1 i x = -2
static enum Context_Stop cJSON_GetContextValue(const cJSON * j) {
    enum Context_Stop x = 0;
    if (NULL != j) {
        if (cJSON_GetStringValue(j) != NULL) {
            if (!strcmp(cJSON_GetStringValue(j), "Interruption.Begin")) x = CONTEXT_STOP_INTERRUPTION_BEGIN;
            else if (!strcmp(cJSON_GetStringValue(j), "Interruption.End")) x = CONTEXT_STOP_INTERRUPTION_END;
            else if (!strcmp(cJSON_GetStringValue(j), "Other")) x = CONTEXT_STOP_OTHER;
            else if (!strcmp(cJSON_GetStringValue(j), "Sample.Clock")) x = CONTEXT_STOP_SAMPLE_CLOCK;
            else if (!strcmp(cJSON_GetStringValue(j), "Sample.Periodic")) x = CONTEXT_STOP_SAMPLE_PERIODIC;
            else if (!strcmp(cJSON_GetStringValue(j), "Transaction.Begin")) x = CONTEXT_STOP_TRANSACTION_BEGIN;
            else if (!strcmp(cJSON_GetStringValue(j), "Transaction.End")) x = CONTEXT_STOP_TRANSACTION_END;
            else if (!strcmp(cJSON_GetStringValue(j), "Trigger")) x = CONTEXT_STOP_TRIGGER;
            else x = -1;
        }
        else
            x = -2;
    }
    return x;
}

static cJSON * cJSON_CreateContext(const enum Context_Stop x) {
    cJSON * j = NULL;
    switch (x) {
        case CONTEXT_STOP_INTERRUPTION_BEGIN: j = cJSON_CreateString("Interruption.Begin"); break;
        case CONTEXT_STOP_INTERRUPTION_END: j = cJSON_CreateString("Interruption.End"); break;
        case CONTEXT_STOP_OTHER: j = cJSON_CreateString("Other"); break;
        case CONTEXT_STOP_SAMPLE_CLOCK: j = cJSON_CreateString("Sample.Clock"); break;
        case CONTEXT_STOP_SAMPLE_PERIODIC: j = cJSON_CreateString("Sample.Periodic"); break;
        case CONTEXT_STOP_TRANSACTION_BEGIN: j = cJSON_CreateString("Transaction.Begin"); break;
        case CONTEXT_STOP_TRANSACTION_END: j = cJSON_CreateString("Transaction.End"); break;
        case CONTEXT_STOP_TRIGGER: j = cJSON_CreateString("Trigger"); break;
    }
    return j;
}

// Modificació: afegeixo l'else de x = -1 i x = -2
static enum Format_Stop cJSON_GetFormatValue(const cJSON * j) {
    enum Format_Stop x = 0;
    if (NULL != j) {
        if (cJSON_GetStringValue(j) != NULL) {
            if (!strcmp(cJSON_GetStringValue(j), "Raw")) x = FORMAT_STOP_RAW;
            else if (!strcmp(cJSON_GetStringValue(j), "SignedData")) x = FORMAT_STOP_SIGNED_DATA;
            else x = -1;
        }
        else
            x = -2;
    }
    return x;
}

static cJSON * cJSON_CreateFormat(const enum Format_Stop x) {
    cJSON * j = NULL;
    switch (x) {
        case FORMAT_STOP_RAW: j = cJSON_CreateString("Raw"); break;
        case FORMAT_STOP_SIGNED_DATA: j = cJSON_CreateString("SignedData"); break;
    }
    return j;
}

// Modificació: afegeixo l'else de x = -1 i x = -2
static enum Location_Stop cJSON_GetLocationValue(const cJSON * j) {
    enum Location_Stop x = 0;
    if (NULL != j) {
        if (cJSON_GetStringValue(j) != NULL) {
            if (!strcmp(cJSON_GetStringValue(j), "Body")) x = LOCATION_STOP_BODY;
            else if (!strcmp(cJSON_GetStringValue(j), "Cable")) x = LOCATION_STOP_CABLE;
            else if (!strcmp(cJSON_GetStringValue(j), "EV")) x = LOCATION_STOP_EV;
            else if (!strcmp(cJSON_GetStringValue(j), "Inlet")) x = LOCATION_STOP_INLET;
            else if (!strcmp(cJSON_GetStringValue(j), "Outlet")) x = LOCATION_STOP_OUTLET;
            else x = -1;
        }
        else
            x = -2;
    }
    return x;
}

static cJSON * cJSON_CreateLocation(const enum Location_Stop x) {
    cJSON * j = NULL;
    switch (x) {
        case LOCATION_STOP_BODY: j = cJSON_CreateString("Body"); break;
        case LOCATION_STOP_CABLE: j = cJSON_CreateString("Cable"); break;
        case LOCATION_STOP_EV: j = cJSON_CreateString("EV"); break;
        case LOCATION_STOP_INLET: j = cJSON_CreateString("Inlet"); break;
        case LOCATION_STOP_OUTLET: j = cJSON_CreateString("Outlet"); break;
    }
    return j;
}

// Modificació: afegeixo l'else de x = -1 i x = -2
static enum Measurand_Stop cJSON_GetMeasurandValue(const cJSON * j) {
    enum Measurand_Stop x = 0;
    if (NULL != j) {
        if (cJSON_GetStringValue(j) != NULL) {
            if (!strcmp(cJSON_GetStringValue(j), "Current.Export")) x = MEASURAND_STOP_CURRENT_EXPORT;
            else if (!strcmp(cJSON_GetStringValue(j), "Current.Import")) x = MEASURAND_STOP_CURRENT_IMPORT;
            else if (!strcmp(cJSON_GetStringValue(j), "Current.Offered")) x = MEASURAND_STOP_CURRENT_OFFERED;
            else if (!strcmp(cJSON_GetStringValue(j), "Energy.Active.Export.Interval")) x = MEASURAND_STOP_ENERGY_ACTIVE_EXPORT_INTERVAL;
            else if (!strcmp(cJSON_GetStringValue(j), "Energy.Active.Export.Register")) x = MEASURAND_STOP_ENERGY_ACTIVE_EXPORT_REGISTER;
            else if (!strcmp(cJSON_GetStringValue(j), "Energy.Active.Import.Interval")) x = MEASURAND_STOP_ENERGY_ACTIVE_IMPORT_INTERVAL;
            else if (!strcmp(cJSON_GetStringValue(j), "Energy.Active.Import.Register")) x = MEASURAND_STOP_ENERGY_ACTIVE_IMPORT_REGISTER;
            else if (!strcmp(cJSON_GetStringValue(j), "Energy.Reactive.Export.Interval")) x = MEASURAND_STOP_ENERGY_REACTIVE_EXPORT_INTERVAL;
            else if (!strcmp(cJSON_GetStringValue(j), "Energy.Reactive.Export.Register")) x = MEASURAND_STOP_ENERGY_REACTIVE_EXPORT_REGISTER;
            else if (!strcmp(cJSON_GetStringValue(j), "Energy.Reactive.Import.Interval")) x = MEASURAND_STOP_ENERGY_REACTIVE_IMPORT_INTERVAL;
            else if (!strcmp(cJSON_GetStringValue(j), "Energy.Reactive.Import.Register")) x = MEASURAND_STOP_ENERGY_REACTIVE_IMPORT_REGISTER;
            else if (!strcmp(cJSON_GetStringValue(j), "Frequency")) x = MEASURAND_STOP_FREQUENCY;
            else if (!strcmp(cJSON_GetStringValue(j), "Power.Active.Export")) x = MEASURAND_STOP_POWER_ACTIVE_EXPORT;
            else if (!strcmp(cJSON_GetStringValue(j), "Power.Active.Import")) x = MEASURAND_STOP_POWER_ACTIVE_IMPORT;
            else if (!strcmp(cJSON_GetStringValue(j), "Power.Factor")) x = MEASURAND_STOP_POWER_FACTOR;
            else if (!strcmp(cJSON_GetStringValue(j), "Power.Offered")) x = MEASURAND_STOP_POWER_OFFERED;
            else if (!strcmp(cJSON_GetStringValue(j), "Power.Reactive.Export")) x = MEASURAND_STOP_POWER_REACTIVE_EXPORT;
            else if (!strcmp(cJSON_GetStringValue(j), "Power.Reactive.Import")) x = MEASURAND_STOP_POWER_REACTIVE_IMPORT;
            else if (!strcmp(cJSON_GetStringValue(j), "RPM")) x = MEASURAND_STOP_RPM;
            else if (!strcmp(cJSON_GetStringValue(j), "SoC")) x = MEASURAND_STOP_SO_C;
            else if (!strcmp(cJSON_GetStringValue(j), "Temperature")) x = MEASURAND_STOP_TEMPERATURE;
            else if (!strcmp(cJSON_GetStringValue(j), "Voltage")) x = MEASURAND_STOP_VOLTAGE;
            else x = -1;
        }
        else
            x = -2;
    }
    return x;
}

static cJSON * cJSON_CreateMeasurand(const enum Measurand_Stop x) {
    cJSON * j = NULL;
    switch (x) {
        case MEASURAND_STOP_CURRENT_EXPORT: j = cJSON_CreateString("Current.Export"); break;
        case MEASURAND_STOP_CURRENT_IMPORT: j = cJSON_CreateString("Current.Import"); break;
        case MEASURAND_STOP_CURRENT_OFFERED: j = cJSON_CreateString("Current.Offered"); break;
        case MEASURAND_STOP_ENERGY_ACTIVE_EXPORT_INTERVAL: j = cJSON_CreateString("Energy.Active.Export.Interval"); break;
        case MEASURAND_STOP_ENERGY_ACTIVE_EXPORT_REGISTER: j = cJSON_CreateString("Energy.Active.Export.Register"); break;
        case MEASURAND_STOP_ENERGY_ACTIVE_IMPORT_INTERVAL: j = cJSON_CreateString("Energy.Active.Import.Interval"); break;
        case MEASURAND_STOP_ENERGY_ACTIVE_IMPORT_REGISTER: j = cJSON_CreateString("Energy.Active.Import.Register"); break;
        case MEASURAND_STOP_ENERGY_REACTIVE_EXPORT_INTERVAL: j = cJSON_CreateString("Energy.Reactive.Export.Interval"); break;
        case MEASURAND_STOP_ENERGY_REACTIVE_EXPORT_REGISTER: j = cJSON_CreateString("Energy.Reactive.Export.Register"); break;
        case MEASURAND_STOP_ENERGY_REACTIVE_IMPORT_INTERVAL: j = cJSON_CreateString("Energy.Reactive.Import.Interval"); break;
        case MEASURAND_STOP_ENERGY_REACTIVE_IMPORT_REGISTER: j = cJSON_CreateString("Energy.Reactive.Import.Register"); break;
        case MEASURAND_STOP_FREQUENCY: j = cJSON_CreateString("Frequency"); break;
        case MEASURAND_STOP_POWER_ACTIVE_EXPORT: j = cJSON_CreateString("Power.Active.Export"); break;
        case MEASURAND_STOP_POWER_ACTIVE_IMPORT: j = cJSON_CreateString("Power.Active.Import"); break;
        case MEASURAND_STOP_POWER_FACTOR: j = cJSON_CreateString("Power.Factor"); break;
        case MEASURAND_STOP_POWER_OFFERED: j = cJSON_CreateString("Power.Offered"); break;
        case MEASURAND_STOP_POWER_REACTIVE_EXPORT: j = cJSON_CreateString("Power.Reactive.Export"); break;
        case MEASURAND_STOP_POWER_REACTIVE_IMPORT: j = cJSON_CreateString("Power.Reactive.Import"); break;
        case MEASURAND_STOP_RPM: j = cJSON_CreateString("RPM"); break;
        case MEASURAND_STOP_SO_C: j = cJSON_CreateString("SoC"); break;
        case MEASURAND_STOP_TEMPERATURE: j = cJSON_CreateString("Temperature"); break;
        case MEASURAND_STOP_VOLTAGE: j = cJSON_CreateString("Voltage"); break;
    }
    return j;
}

// Modificació: afegeixo l'else de x = -1 i x = -2
static enum Phase_Stop cJSON_GetPhaseValue(const cJSON * j) {
    enum Phase_Stop x = 0;
    if (NULL != j) {
        if (cJSON_GetStringValue(j) != NULL) {
            if (!strcmp(cJSON_GetStringValue(j), "L1")) x = PHASE_STOP_L1;
            else if (!strcmp(cJSON_GetStringValue(j), "L1-L2")) x = PHASE_STOP_L1_L2;
            else if (!strcmp(cJSON_GetStringValue(j), "L1-N")) x = PHASE_STOP_L1_N;
            else if (!strcmp(cJSON_GetStringValue(j), "L2")) x = PHASE_STOP_L2;
            else if (!strcmp(cJSON_GetStringValue(j), "L2-L3")) x = PHASE_STOP_L2_L3;
            else if (!strcmp(cJSON_GetStringValue(j), "L2-N")) x = PHASE_STOP_L2_N;
            else if (!strcmp(cJSON_GetStringValue(j), "L3")) x = PHASE_STOP_L3;
            else if (!strcmp(cJSON_GetStringValue(j), "L3-L1")) x = PHASE_STOP_L3_L1;
            else if (!strcmp(cJSON_GetStringValue(j), "L3-N")) x = PHASE_STOP_L3_N;
            else if (!strcmp(cJSON_GetStringValue(j), "N")) x = PHASE_STOP_N;
            else x = -1;
        }
        else
            x = -2;
    }
    return x;
}

static cJSON * cJSON_CreatePhase(const enum Phase_Stop x) {
    cJSON * j = NULL;
    switch (x) {
        case PHASE_STOP_L1: j = cJSON_CreateString("L1"); break;
        case PHASE_STOP_L1_L2: j = cJSON_CreateString("L1-L2"); break;
        case PHASE_STOP_L1_N: j = cJSON_CreateString("L1-N"); break;
        case PHASE_STOP_L2: j = cJSON_CreateString("L2"); break;
        case PHASE_STOP_L2_L3: j = cJSON_CreateString("L2-L3"); break;
        case PHASE_STOP_L2_N: j = cJSON_CreateString("L2-N"); break;
        case PHASE_STOP_L3: j = cJSON_CreateString("L3"); break;
        case PHASE_STOP_L3_L1: j = cJSON_CreateString("L3-L1"); break;
        case PHASE_STOP_L3_N: j = cJSON_CreateString("L3-N"); break;
        case PHASE_STOP_N: j = cJSON_CreateString("N"); break;
    }
    return j;
}

// Modificació: afegeixo l'else de x = -1 i x = -2
static enum Unit_Stop cJSON_GetUnitValue(const cJSON * j) {
    enum Unit_Stop x = 0;
    if (NULL != j) {
        if (cJSON_GetStringValue(j) != NULL) {
            if (!strcmp(cJSON_GetStringValue(j), "A")) x = UNIT_STOP_A;
            else if (!strcmp(cJSON_GetStringValue(j), "Celcius")) x = UNIT_STOP_CELCIUS;
            else if (!strcmp(cJSON_GetStringValue(j), "Fahrenheit")) x = UNIT_STOP_FAHRENHEIT;
            else if (!strcmp(cJSON_GetStringValue(j), "K")) x = UNIT_STOP_K;
            else if (!strcmp(cJSON_GetStringValue(j), "kvar")) x = UNIT_STOP_KVAR;
            else if (!strcmp(cJSON_GetStringValue(j), "kvarh")) x = UNIT_STOP_KVARH;
            else if (!strcmp(cJSON_GetStringValue(j), "kVA")) x = UNIT_STOP_K_VA;
            else if (!strcmp(cJSON_GetStringValue(j), "kW")) x = UNIT_STOP_K_W;
            else if (!strcmp(cJSON_GetStringValue(j), "kWh")) x = UNIT_STOP_K_WH;
            else if (!strcmp(cJSON_GetStringValue(j), "Percent")) x = UNIT_STOP_PERCENT;
            else if (!strcmp(cJSON_GetStringValue(j), "V")) x = UNIT_STOP_V;
            else if (!strcmp(cJSON_GetStringValue(j), "VA")) x = UNIT_STOP_VA;
            else if (!strcmp(cJSON_GetStringValue(j), "var")) x = UNIT_STOP_VAR;
            else if (!strcmp(cJSON_GetStringValue(j), "varh")) x = UNIT_STOP_VARH;
            else if (!strcmp(cJSON_GetStringValue(j), "W")) x = UNIT_STOP_W;
            else if (!strcmp(cJSON_GetStringValue(j), "Wh")) x = UNIT_STOP_WH;
            else x = -1;
        }
        else
            x = -2;
    }
    return x;
}

static cJSON * cJSON_CreateUnit(const enum Unit_Stop x) {
    cJSON * j = NULL;
    switch (x) {
        case UNIT_STOP_A: j = cJSON_CreateString("A"); break;
        case UNIT_STOP_CELCIUS: j = cJSON_CreateString("Celcius"); break;
        case UNIT_STOP_FAHRENHEIT: j = cJSON_CreateString("Fahrenheit"); break;
        case UNIT_STOP_K: j = cJSON_CreateString("K"); break;
        case UNIT_STOP_KVAR: j = cJSON_CreateString("kvar"); break;
        case UNIT_STOP_KVARH: j = cJSON_CreateString("kvarh"); break;
        case UNIT_STOP_K_VA: j = cJSON_CreateString("kVA"); break;
        case UNIT_STOP_K_W: j = cJSON_CreateString("kW"); break;
        case UNIT_STOP_K_WH: j = cJSON_CreateString("kWh"); break;
        case UNIT_STOP_PERCENT: j = cJSON_CreateString("Percent"); break;
        case UNIT_STOP_V: j = cJSON_CreateString("V"); break;
        case UNIT_STOP_VA: j = cJSON_CreateString("VA"); break;
        case UNIT_STOP_VAR: j = cJSON_CreateString("var"); break;
        case UNIT_STOP_VARH: j = cJSON_CreateString("varh"); break;
        case UNIT_STOP_W: j = cJSON_CreateString("W"); break;
        case UNIT_STOP_WH: j = cJSON_CreateString("Wh"); break;
    }
    return j;
}

static struct SampledValue_Stop * cJSON_ParseSampledValue(const char * s) {
    struct SampledValue_Stop * x = NULL;
    if (NULL != s) {
        cJSON * j = cJSON_Parse(s);
        if (NULL != j) {
            x = cJSON_GetSampledValueValue(j);
            cJSON_Delete(j);
        }
    }
    return x;
}

static struct SampledValue_Stop * cJSON_GetSampledValueValue(const cJSON * j) {
    struct SampledValue_Stop * x = NULL;
    if (NULL != j) {
        if (NULL != (x = cJSON_malloc(sizeof(struct SampledValue_Stop)))) {
            memset(x, 0, sizeof(struct SampledValue_Stop));
            if (cJSON_HasObjectItem(j, "context")) {
                if (NULL != (x->context = cJSON_malloc(sizeof(enum Context_Stop)))) {
                    *x->context = cJSON_GetContextValue(cJSON_GetObjectItemCaseSensitive(j, "context"));
                }
            }
            if (cJSON_HasObjectItem(j, "format")) {
                if (NULL != (x->format = cJSON_malloc(sizeof(enum Format_Stop)))) {
                    *x->format = cJSON_GetFormatValue(cJSON_GetObjectItemCaseSensitive(j, "format"));
                }
            }
            if (cJSON_HasObjectItem(j, "location")) {
                if (NULL != (x->location = cJSON_malloc(sizeof(enum Location_Stop)))) {
                    *x->location = cJSON_GetLocationValue(cJSON_GetObjectItemCaseSensitive(j, "location"));
                }
            }
            if (cJSON_HasObjectItem(j, "measurand")) {
                if (NULL != (x->measurand = cJSON_malloc(sizeof(enum Measurand_Stop)))) {
                    *x->measurand = cJSON_GetMeasurandValue(cJSON_GetObjectItemCaseSensitive(j, "measurand"));
                }
            }
            if (cJSON_HasObjectItem(j, "phase")) {
                if (NULL != (x->phase = cJSON_malloc(sizeof(enum Phase_Stop)))) {
                    *x->phase = cJSON_GetPhaseValue(cJSON_GetObjectItemCaseSensitive(j, "phase"));
                }
            }
            if (cJSON_HasObjectItem(j, "unit")) {
                if (NULL != (x->unit = cJSON_malloc(sizeof(enum Unit_Stop)))) {
                    *x->unit = cJSON_GetUnitValue(cJSON_GetObjectItemCaseSensitive(j, "unit"));
                }
            }
            if (cJSON_HasObjectItem(j, "value")) {
                x->value = mystrdup(cJSON_GetStringValue(cJSON_GetObjectItemCaseSensitive(j, "value")));
            }
            else {
                if (NULL != (x->value = cJSON_malloc(sizeof(char)))) {
                    x->value[0] = '\0';
                }
            }
        }
    }
    return x;
}

static cJSON * cJSON_CreateSampledValue(const struct SampledValue_Stop * x) {
    cJSON * j = NULL;
    if (NULL != x) {
        if (NULL != (j = cJSON_CreateObject())) {
            if (NULL != x->context) {
                cJSON_AddItemToObject(j, "context", cJSON_CreateContext(*x->context));
            }
            if (NULL != x->format) {
                cJSON_AddItemToObject(j, "format", cJSON_CreateFormat(*x->format));
            }
            if (NULL != x->location) {
                cJSON_AddItemToObject(j, "location", cJSON_CreateLocation(*x->location));
            }
            if (NULL != x->measurand) {
                cJSON_AddItemToObject(j, "measurand", cJSON_CreateMeasurand(*x->measurand));
            }
            if (NULL != x->phase) {
                cJSON_AddItemToObject(j, "phase", cJSON_CreatePhase(*x->phase));
            }
            if (NULL != x->unit) {
                cJSON_AddItemToObject(j, "unit", cJSON_CreateUnit(*x->unit));
            }
            if (NULL != x->value) {
                cJSON_AddStringToObject(j, "value", x->value);
            }
            else {
                cJSON_AddStringToObject(j, "value", "");
            }
        }
    }
    return j;
}

static char * cJSON_PrintSampledValue(const struct SampledValue_Stop * x) {
    char * s = NULL;
    if (NULL != x) {
        cJSON * j = cJSON_CreateSampledValue(x);
        if (NULL != j) {
            s = cJSON_Print(j);
            cJSON_Delete(j);
        }
    }
    return s;
}

static void cJSON_DeleteSampledValue(struct SampledValue_Stop * x) {
    if (NULL != x) {
        if (NULL != x->context) {
            cJSON_free(x->context);
        }
        if (NULL != x->format) {
            cJSON_free(x->format);
        }
        if (NULL != x->location) {
            cJSON_free(x->location);
        }
        if (NULL != x->measurand) {
            cJSON_free(x->measurand);
        }
        if (NULL != x->phase) {
            cJSON_free(x->phase);
        }
        if (NULL != x->unit) {
            cJSON_free(x->unit);
        }
        if (NULL != x->value) {
            cJSON_free(x->value);
        }
        cJSON_free(x);
    }
}

static struct TransactionDatum * cJSON_ParseTransactionDatum(const char * s) {
    struct TransactionDatum * x = NULL;
    if (NULL != s) {
        cJSON * j = cJSON_Parse(s);
        if (NULL != j) {
            x = cJSON_GetTransactionDatumValue(j);
            cJSON_Delete(j);
        }
    }
    return x;
}

static struct TransactionDatum * cJSON_GetTransactionDatumValue(const cJSON * j) {
    struct TransactionDatum * x = NULL;
    if (NULL != j) {
        if (NULL != (x = cJSON_malloc(sizeof(struct TransactionDatum)))) {
            memset(x, 0, sizeof(struct TransactionDatum));
            if (cJSON_HasObjectItem(j, "sampledValue")) {
                list_t * x1 = list_create(false, NULL);
                if (NULL != x1) {
                    cJSON * e1 = NULL;
                    cJSON * j1 = cJSON_GetObjectItemCaseSensitive(j, "sampledValue");
                    cJSON_ArrayForEach(e1, j1) {
                        list_add_tail(x1, cJSON_GetSampledValueValue(e1), sizeof(struct SampledValue *));
                    }
                    x->sampled_value = x1;
                }
            }
            else {
                x->sampled_value = list_create(false, NULL);
            }
            if (cJSON_HasObjectItem(j, "timestamp")) {
                x->timestamp = mystrdup(cJSON_GetStringValue(cJSON_GetObjectItemCaseSensitive(j, "timestamp")));
            }
            else {
                if (NULL != (x->timestamp = cJSON_malloc(sizeof(char)))) {
                    x->timestamp[0] = '\0';
                }
            }
        }
    }
    return x;
}

static cJSON * cJSON_CreateTransactionDatum(const struct TransactionDatum * x) {
    cJSON * j = NULL;
    if (NULL != x) {
        if (NULL != (j = cJSON_CreateObject())) {
            if (NULL != x->sampled_value) {
                cJSON * j1 = cJSON_AddArrayToObject(j, "sampledValue");
                if (NULL != j1) {
                    struct SampledValue_Stop * x1 = list_get_head(x->sampled_value);
                    while (NULL != x1) {
                        cJSON_AddItemToArray(j1, cJSON_CreateSampledValue(x1));
                        x1 = list_get_next(x->sampled_value);
                    }
                }
            }
            if (NULL != x->timestamp) {
                cJSON_AddStringToObject(j, "timestamp", x->timestamp);
            }
            else {
                cJSON_AddStringToObject(j, "timestamp", "");
            }
        }
    }
    return j;
}

static char * cJSON_PrintTransactionDatum(const struct TransactionDatum * x) {
    char * s = NULL;
    if (NULL != x) {
        cJSON * j = cJSON_CreateTransactionDatum(x);
        if (NULL != j) {
            s = cJSON_Print(j);
            cJSON_Delete(j);
        }
    }
    return s;
}

static void cJSON_DeleteTransactionDatum(struct TransactionDatum * x) {
    if (NULL != x) {
        if (NULL != x->sampled_value) {
            struct SampledValue_Stop * x1 = list_get_head(x->sampled_value);
            while (NULL != x1) {
                cJSON_DeleteSampledValue(x1);
                x1 = list_get_next(x->sampled_value);
            }
            list_release(x->sampled_value);
        }
        if (NULL != x->timestamp) {
            cJSON_free(x->timestamp);
        }
        cJSON_free(x);
    }
}

struct StopTransactionReq * cJSON_ParseStopTransactionReq(const char * s) {
    struct StopTransactionReq * x = NULL;
    if (NULL != s) {
        cJSON * j = cJSON_Parse(s);
        if (NULL != j) {
            x = cJSON_GetStopTransactionReqValue(j);
            cJSON_Delete(j);
        }
    }
    return x;
}

// Modificació: afegit l'else de meter_stop = -1 i transaction_id = -1
static struct StopTransactionReq * cJSON_GetStopTransactionReqValue(const cJSON * j) {
    struct StopTransactionReq * x = NULL;
    if (NULL != j) {
        if (NULL != (x = cJSON_malloc(sizeof(struct StopTransactionReq)))) {
            memset(x, 0, sizeof(struct StopTransactionReq));
            if (cJSON_HasObjectItem(j, "idTag")) {
                x->id_tag = mystrdup(cJSON_GetStringValue(cJSON_GetObjectItemCaseSensitive(j, "idTag")));
            }
            if (cJSON_HasObjectItem(j, "meterStop")) {
                x->meter_stop = cJSON_GetNumberValue(cJSON_GetObjectItemCaseSensitive(j, "meterStop"));
            }
            else
                x->meter_stop = -1;
            if (cJSON_HasObjectItem(j, "reason")) {
                if (NULL != (x->reason = cJSON_malloc(sizeof(enum Reason)))) {
                    *x->reason = cJSON_GetReasonValue(cJSON_GetObjectItemCaseSensitive(j, "reason"));
                }
            }
            if (cJSON_HasObjectItem(j, "timestamp")) {
                x->timestamp = mystrdup(cJSON_GetStringValue(cJSON_GetObjectItemCaseSensitive(j, "timestamp")));
            }
            else {
                if (NULL != (x->timestamp = cJSON_malloc(sizeof(char)))) {
                    x->timestamp[0] = '\0';
                }
            }
            if (cJSON_HasObjectItem(j, "transactionData")) {
                list_t * x1 = list_create(false, NULL);
                if (NULL != x1) {
                    cJSON * e1 = NULL;
                    cJSON * j1 = cJSON_GetObjectItemCaseSensitive(j, "transactionData");
                    cJSON_ArrayForEach(e1, j1) {
                        list_add_tail(x1, cJSON_GetTransactionDatumValue(e1), sizeof(struct TransactionDatum *));
                    }
                    x->transaction_data = x1;
                }
            }
            if (cJSON_HasObjectItem(j, "transactionId")) {
                x->transaction_id = cJSON_GetNumberValue(cJSON_GetObjectItemCaseSensitive(j, "transactionId"));
            }
            else
                x->transaction_id = -1;
        }
    }
    return x;
}

static cJSON * cJSON_CreateStopTransactionReq(const struct StopTransactionReq * x) {
    cJSON * j = NULL;
    if (NULL != x) {
        if (NULL != (j = cJSON_CreateObject())) {
            if (NULL != x->id_tag) {
                cJSON_AddStringToObject(j, "idTag", x->id_tag);
            }
            cJSON_AddNumberToObject(j, "meterStop", x->meter_stop);
            if (NULL != x->reason) {
                cJSON_AddItemToObject(j, "reason", cJSON_CreateReason(*x->reason));
            }
            if (NULL != x->timestamp) {
                cJSON_AddStringToObject(j, "timestamp", x->timestamp);
            }
            else {
                cJSON_AddStringToObject(j, "timestamp", "");
            }
            if (NULL != x->transaction_data) {
                cJSON * j1 = cJSON_AddArrayToObject(j, "transactionData");
                if (NULL != j1) {
                    struct TransactionDatum * x1 = list_get_head(x->transaction_data);
                    while (NULL != x1) {
                        cJSON_AddItemToArray(j1, cJSON_CreateTransactionDatum(x1));
                        x1 = list_get_next(x->transaction_data);
                    }
                }
            }
            cJSON_AddNumberToObject(j, "transactionId", x->transaction_id);
        }
    }
    return j;
}

char * cJSON_PrintStopTransactionReq(const struct StopTransactionReq * x) {
    char * s = NULL;
    if (NULL != x) {
        cJSON * j = cJSON_CreateStopTransactionReq(x);
        if (NULL != j) {
            s = cJSON_Print(j);
            cJSON_Delete(j);
        }
    }
    return s;
}

static void cJSON_DeleteStopTransactionReq(struct StopTransactionReq * x) {
    if (NULL != x) {
        if (NULL != x->id_tag) {
            cJSON_free(x->id_tag);
        }
        if (NULL != x->reason) {
            cJSON_free(x->reason);
        }
        if (NULL != x->timestamp) {
            cJSON_free(x->timestamp);
        }
        if (NULL != x->transaction_data) {
            struct TransactionDatum * x1 = list_get_head(x->transaction_data);
            while (NULL != x1) {
                cJSON_DeleteTransactionDatum(x1);
                x1 = list_get_next(x->transaction_data);
            }
            list_release(x->transaction_data);
        }
        cJSON_free(x);
    }
}

#ifdef __cplusplus
}
#endif

#endif /* __STDOUT__ */
